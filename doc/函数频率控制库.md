 

<think>


</think>


已思考 8s 

 下面给你一个 **Linux/C++ 单核友好**、**好用高效**的“函数运行频率控制”小库：既能像 ROS 那样 `Rate` 控频，也能用一个 **协作式调度器** 同时控制多路任务（图像读取/识别/路径检测/电机控制高频/传感器/上传/显示）。  
特点：**steady_clock 单调时钟**、`sleep_until` 省 CPU、支持 **超时(跑飞)检测/统计**、支持 **Catch-up/Skip** 两种错过周期策略。

---

## 目录结构（建议）
```
rate_control/
  include/
    rate_control.hpp
  src/
    rate_control.cpp
  examples/
    smartcar_demo.cpp
  CMakeLists.txt
  README.md
```

---

# 1) 头文件：`include/rate_control.hpp`
```cpp
#pragma once
#include <chrono>
#include <cstdint>
#include <functional>
#include <string>
#include <vector>

namespace rate_control {

using Clock = std::chrono::steady_clock;

enum class MissPolicy : uint8_t {
    CatchUp, // 追赶：next += period，可能连续执行几次（不sleep）追到当前
    Skip     // 跳过：next = now + period，避免“补课”导致抖动/堆积
};

struct RateStats {
    uint64_t cycles = 0;        // 总周期数
    uint64_t overruns = 0;      // 超时次数（回调耗时 > period 或错过deadline）
    uint64_t max_late_ns = 0;   // 最大延迟（ns）
};

class Rate {
public:
    // hz: 频率（Hz），policy: 错过周期策略
    explicit Rate(double hz, MissPolicy policy = MissPolicy::CatchUp);

    // 设定下一次周期基准：通常在循环开始前调用一次即可
    void reset(Clock::time_point start = Clock::now());

    // 等待到下一个周期点；返回是否发生了 overrun（本周期已经落后）
    bool sleep();

    // 本周期结束时刻（下一次触发点）
    Clock::time_point next_deadline() const { return next_; }

    // 周期时长
    std::chrono::nanoseconds period() const { return period_; }

    const RateStats& stats() const { return stats_; }

private:
    std::chrono::nanoseconds period_;
    Clock::time_point next_{};
    MissPolicy policy_;
    RateStats stats_{};
};

struct Task {
    std::string name;
    std::chrono::nanoseconds period;
    MissPolicy policy = MissPolicy::CatchUp;
    std::function<void()> fn;

    // 运行时字段
    Clock::time_point next;
    RateStats stats;
};

class Scheduler {
public:
    Scheduler() = default;

    // hz: 频率；name: 用于调试统计
    void add_task(const std::string& name, double hz, std::function<void()> fn,
                  MissPolicy policy = MissPolicy::CatchUp);

    // 运行调度循环（单核协作式）。stop_flag 返回 true 时停止。
    // 建议：回调里不要长时间阻塞；耗时任务可拆小步或用队列/状态机。
    void run(const std::function<bool()>& stop_flag);

    const std::vector<Task>& tasks() const { return tasks_; }

private:
    std::vector<Task> tasks_;

    static std::chrono::nanoseconds hz_to_period(double hz);
};

} // namespace rate_control
```

---

# 2) 实现文件：`src/rate_control.cpp`
```cpp
#include "rate_control.hpp"
#include <algorithm>
#include <cmath>
#include <thread>

namespace rate_control {

static inline uint64_t to_ns_u64(std::chrono::nanoseconds ns) {
    return static_cast<uint64_t>(ns.count() < 0 ? 0 : ns.count());
}

std::chrono::nanoseconds Scheduler::hz_to_period(double hz) {
    if (hz <= 0.0) {
        return std::chrono::seconds(1);
    }
    const double sec = 1.0 / hz;
    const auto ns = static_cast<int64_t>(sec * 1e9);
    return std::chrono::nanoseconds(std::max<int64_t>(1, ns));
}

Rate::Rate(double hz, MissPolicy policy)
    : period_(Scheduler::hz_to_period(hz)), policy_(policy) {
    reset();
}

void Rate::reset(Clock::time_point start) {
    next_ = start + period_;
    stats_ = RateStats{};
}

bool Rate::sleep() {
    stats_.cycles++;

    const auto now = Clock::now();
    bool overrun = false;

    if (now < next_) {
        std::this_thread::sleep_until(next_);
        next_ += period_;
        return false;
    }

    // 已经落后（错过 deadline）
    overrun = true;
    stats_.overruns++;

    const auto late = now - next_;
    stats_.max_late_ns = std::max<uint64_t>(stats_.max_late_ns, to_ns_u64(std::chrono::duration_cast<std::chrono::nanoseconds>(late)));

    if (policy_ == MissPolicy::CatchUp) {
        // 追赶到 now 之后的第一个 next_
        do {
            next_ += period_;
        } while (next_ <= now);
    } else {
        // Skip：直接跳到 now + period
        next_ = now + period_;
    }

    return overrun;
}

void Scheduler::add_task(const std::string& name, double hz, std::function<void()> fn,
                         MissPolicy policy) {
    Task t;
    t.name = name;
    t.period = hz_to_period(hz);
    t.policy = policy;
    t.fn = std::move(fn);
    t.next = Clock::now() + t.period;
    tasks_.push_back(std::move(t));
}

void Scheduler::run(const std::function<bool()>& stop_flag) {
    while (!stop_flag()) {
        if (tasks_.empty()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            continue;
        }

        // 找到最早需要执行的任务
        auto it = std::min_element(tasks_.begin(), tasks_.end(),
                                   [](const Task& a, const Task& b) { return a.next < b.next; });

        const auto now = Clock::now();
        if (now < it->next) {
            std::this_thread::sleep_until(it->next);
        }

        // 可能 sleep 后时间变化
        const auto tnow = Clock::now();

        // 执行任务（协作式：单核顺序跑）
        // 统计：是否超期
        it->stats.cycles++;

        bool missed = (tnow > it->next);
        if (missed) {
            it->stats.overruns++;
            const auto late = tnow - it->next;
            it->stats.max_late_ns = std::max<uint64_t>(
                it->stats.max_late_ns,
                to_ns_u64(std::chrono::duration_cast<std::chrono::nanoseconds>(late)));
        }

        // 执行回调，并记录执行耗时（可用于判断“回调本身超时”）
        const auto begin = Clock::now();
        it->fn();
        const auto end = Clock::now();

        // 如果回调耗时超过周期，也算一种 overrun（单核尤其重要）
        const auto exec_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);
        if (exec_ns > it->period) {
            it->stats.overruns++;
            it->stats.max_late_ns = std::max<uint64_t>(it->stats.max_late_ns, to_ns_u64(exec_ns - it->period));
        }

        // 更新 next
        const auto after = Clock::now();
        if (it->policy == MissPolicy::CatchUp) {
            // 追赶：next += period，直到 > now
            do {
                it->next += it->period;
            } while (it->next <= after);
        } else {
            // Skip：丢弃积压，稳定节拍
            it->next = after + it->period;
        }
    }
}

} // namespace rate_control
```

---

# 3) 例程：`examples/smartcar_demo.cpp`
这个例子模拟智能小车典型任务频率（你可按实际需求调整）：
- 电机控制：**200Hz**（高频）
- 传感器读取：100Hz
- 图像读取：30Hz
- 识别：15Hz
- 路径检测：20Hz
- 显示：10Hz
- 数据上传：1Hz（用 Skip 更合适，避免网络卡顿导致补课）

```cpp
#include "rate_control.hpp"
#include <atomic>
#include <csignal>
#include <iostream>

using namespace rate_control;

static std::atomic<bool> g_stop{false};

static void on_sigint(int) {
    g_stop.store(true);
}

int main() {
    std::signal(SIGINT, on_sigint);

    Scheduler sch;

    // 假装这些是你的业务函数（建议短小、非阻塞）
    sch.add_task("motor_control_200hz", 200.0, [](){
        // 电机PWM/闭环控制（高频）
        // TODO: write_motor_pwm();
    }, MissPolicy::CatchUp);

    sch.add_task("sensor_100hz", 100.0, [](){
        // IMU/里程计/超声/ToF等
        // TODO: read_sensors();
    }, MissPolicy::CatchUp);

    sch.add_task("image_read_30hz", 30.0, [](){
        // 摄像头取帧（尽量用非阻塞/双缓冲）
        // TODO: camera_grab();
    }, MissPolicy::Skip); // 取帧更适合 Skip：落后就丢帧，保证“新鲜度”

    sch.add_task("perception_15hz", 15.0, [](){
        // 目标识别/语义分割等
        // TODO: run_inference();
    }, MissPolicy::Skip); // 感知任务也常用 Skip，避免补课导致延迟越来越大

    sch.add_task("path_detect_20hz", 20.0, [](){
        // 车道线/路径检测
        // TODO: detect_path();
    }, MissPolicy::CatchUp);

    sch.add_task("display_10hz", 10.0, [](){
        // UI/OSD/串口屏等
        // TODO: render_display();
    }, MissPolicy::Skip);

    sch.add_task("upload_1hz", 1.0, [](){
        // 上传遥测数据/日志
        // TODO: upload_telemetry();
    }, MissPolicy::Skip);

    // 每2秒打印一次统计信息（不建议太频繁打印，影响实时性）
    Rate print_rate(0.5, MissPolicy::Skip);
    print_rate.reset();

    std::cout << "Smartcar scheduler running. Press Ctrl+C to stop.\n";

    sch.add_task("stats_printer_0.5hz", 0.5, [&](){
        std::cout << "\n--- Stats ---\n";
        for (const auto& t : sch.tasks()) {
            std::cout << t.name
                      << " cycles=" << t.stats.cycles
                      << " overruns=" << t.stats.overruns
                      << " max_late_ns=" << t.stats.max_late_ns
                      << "\n";
        }
    }, MissPolicy::Skip);

    sch.run([](){ return g_stop.load(); });

    std::cout << "Stopped.\n";
    return 0;
}
```

---

# 4) 构建文件：`CMakeLists.txt`
```cmake
cmake_minimum_required(VERSION 3.10)
project(rate_control_lib LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_library(rate_control
    src/rate_control.cpp
)
target_include_directories(rate_control PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

add_executable(smartcar_demo examples/smartcar_demo.cpp)
target_link_libraries(smartcar_demo PRIVATE rate_control)
```

---

# 5) README：`README.md`
```md
# rate_control (Linux/C++)

一个轻量、高效、单核友好的函数频率控制库，适用于智能小车常见任务：
- 图像读取、识别、路径检测
- 电机控制（高频）
- 传感器读取
- 数据上传、显示等

## 特性
- 使用 `std::chrono::steady_clock`（单调时钟）避免系统时间跳变影响
- `sleep_until` 节能省 CPU
- 支持两种错过周期策略：
  - `CatchUp`：追赶周期（适合控制环）
  - `Skip`：跳过积压（适合图像/网络/显示等需要“新鲜度”的任务）
- 统计信息：周期数、超时次数、最大延迟

## 适用建议（智能小车）
- 电机控制、传感器融合：用 `CatchUp`（更稳定的控制节拍）
- 相机取帧、深度学习推理、显示、数据上传：用 `Skip`（落后就丢帧/丢周期，保证低延迟）

> 单核CPU上这是“协作式调度”：所有任务在同一线程顺序执行。
> 因此回调函数应避免长时间阻塞；耗时工作建议拆小步/状态机、或使用双缓冲队列让高频控制优先。

## 构建
```bash
mkdir -p build
cd build
cmake ..
cmake --build -j
```

## 运行例程
```bash
./smartcar_demo
# Ctrl+C 退出
```

## API 简述
### Rate
```cpp
rate_control::Rate r(200.0); // 200Hz
r.reset();
while (...) {
  // do work
  r.sleep(); // 自动对齐到下一周期
}
```

### Scheduler
```cpp
rate_control::Scheduler sch;
sch.add_task("motor", 200.0, motor_fn, MissPolicy::CatchUp);
sch.add_task("camera", 30.0, camera_fn, MissPolicy::Skip);
sch.run(stop_flag);
```

## 性能与实时性注意事项
- `sleep_until` 依赖系统调度粒度；需要更强实时性可考虑：
  - 提高线程优先级（SCHED_FIFO/RT），或绑定CPU
  - 回调内减少 `printf/iostream` 等IO
  - 对高频控制回调做最小化、固定时间预算
- 若某任务经常 overrun：
  - 降频或优化回调耗时
  - 对感知/上传类任务改用 `Skip`
```

---

## 你接下来可以直接用的建议（按你场景）
- 电机控制：200~500Hz，`CatchUp`
- 传感器读取：100~200Hz，`CatchUp`
- 图像读取：30~60Hz，`Skip`（丢帧比堆积强）
- 识别：10~30Hz，`Skip`
- 路径检测：20~50Hz，视算法，通常 `CatchUp` 或 `Skip` 都可（更关注稳定控制用 CatchUp，更关注低延迟用 Skip）
- 上传：0.5~5Hz，`Skip`
- 显示：5~20Hz，`Skip`

如果你希望我再加两个能力（仍保持轻量高效）：  
1) **任务运行耗时的滑动平均/抖动统计**；2) **“时间预算”保护（超过预算就提前返回/跳过下一次）**，我也可以把接口扩展好并给出示例。

