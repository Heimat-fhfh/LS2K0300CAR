# rate_control (Linux/C++)

一个轻量、高效、单核友好的函数频率控制库，适用于智能小车常见任务：
- 图像读取、识别、路径检测
- 电机控制（高频）
- 传感器读取
- 数据上传、显示等

## 特性
- 使用 `std::chrono::steady_clock`（单调时钟）避免系统时间跳变影响
- `sleep_until` 节能省 CPU
- 支持两种错过周期策略：
  - `CatchUp`：追赶周期（适合控制环）
  - `Skip`：跳过积压（适合图像/网络/显示等需要“新鲜度”的任务）
- 统计信息：周期数、超时次数、最大延迟

## 适用建议（智能小车）
- 电机控制、传感器融合：用 `CatchUp`（更稳定的控制节拍）
- 相机取帧、深度学习推理、显示、数据上传：用 `Skip`（落后就丢帧/丢周期，保证低延迟）

> 单核CPU上这是“协作式调度”：所有任务在同一线程顺序执行。
> 因此回调函数应避免长时间阻塞；耗时工作建议拆小步/状态机、或使用双缓冲队列让高频控制优先。

## 构建
```bash
mkdir -p build
cd build
cmake ..
cmake --build -j
``` 

## 运行例程
```bash
./smartcar_demo
# Ctrl+C 退出
```

## API 简述
### Rate
```cpp
rate_control::Rate r(200.0); // 200Hz
r.reset();
while (...) {
  // do work
  r.sleep(); // 自动对齐到下一周期
}
```

### Scheduler
```cpp
rate_control::Scheduler sch;
sch.add_task("motor", 200.0, motor_fn, MissPolicy::CatchUp);
sch.add_task("camera", 30.0, camera_fn, MissPolicy::Skip);
sch.run(stop_flag);
```

## 性能与实时性注意事项
- `sleep_until` 依赖系统调度粒度；需要更强实时性可考虑：
  - 提高线程优先级（SCHED_FIFO/RT），或绑定CPU
  - 回调内减少 `printf/iostream` 等IO
  - 对高频控制回调做最小化、固定时间预算
- 若某任务经常 overrun：
  - 降频或优化回调耗时
  - 对感知/上传类任务改用 `Skip`